//! SeaORM Entity. Generated by sea-orm-codegen 0.8.0

use anyhow::Result;
use sea_orm::{entity::prelude::*, Set, UpdateMany, Condition, sea_query::{Expr, SimpleExpr}};
use serde::Serialize;

#[derive(Debug, Clone, PartialEq, EnumIter, DeriveActiveEnum, Serialize, Copy)]
#[sea_orm(rs_type = "String", db_type = "String(Some(16))")]
pub enum BondStatus {
  #[sea_orm(string_value = "Active")]
  Active,
  #[sea_orm(string_value = "Archived")]
  Archived,
}


#[derive(Clone, Debug, PartialEq, DeriveEntityModel, Serialize)]
#[serde(rename_all = "camelCase")]
#[sea_orm(table_name = "bonds")]
pub struct Model {
  #[sea_orm(primary_key)]
  pub id: i64,
  pub uid: String,
  pub name: String,
  pub status: BondStatus,
  pub emission: String,
  pub kind: String,
  pub currency : String,
  pub category_id: Option<i64>,
  pub integration_id: Option<i64>,
  pub account_id: Option<i64>,
  pub wallet_id: Option<i64>,
  pub start_date: Date,
  pub interest_date: Date,
  pub end_date: Date,
  pub updated_at: DateTime,
  //TODO: in future versions migrate to native postgresql Date arrays
  pub period_start: Json,
  pub period_end: Json,
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
  #[sea_orm(
    belongs_to = "super::wallets::Entity",
    from = "Column::WalletId",
    to = "super::wallets::Column::Id",
    on_update = "NoAction",
    on_delete = "SetNull"
  )]
  Wallet,
  #[sea_orm(
    belongs_to = "super::accounts::Entity",
    from = "Column::AccountId",
    to = "super::accounts::Column::Id",
    on_update = "NoAction",
    on_delete = "SetNull"
  )]
  Account,
  #[sea_orm(
    belongs_to = "super::categories::Entity",
    from = "Column::CategoryId",
    to = "super::categories::Column::Id",
    on_update = "NoAction",
    on_delete = "SetNull"
  )]
  Category,
  #[sea_orm(
    belongs_to = "super::integrations::Entity",
    from = "Column::IntegrationId",
    to = "super::integrations::Column::Id",
    on_update = "NoAction",
    on_delete = "Cascade"
  )]
  Integration,
  #[sea_orm(
    has_many = "super::bond_performances::Entity",
    from = "Column::Id",
    to = "super::bond_performances::Column::BondId",
    on_update = "NoAction",
    on_delete = "Cascade"
  )]
  BondPerformance,
  #[sea_orm(
    has_many = "super::bond_monthly_performances::Entity",
    from = "Column::Id",
    to = "super::bond_monthly_performances::Column::BondId",
    on_update = "NoAction",
    on_delete = "Cascade"
  )]
  BondMonthlyPerformance,
  #[sea_orm(
    has_many = "super::interest_rate_histories::Entity",
    from = "Column::Id",
    to = "super::interest_rate_histories::Column::BondId",
    on_update = "NoAction",
    on_delete = "Cascade"
  )]
  InterestRateHistories,
}

impl Related<super::accounts::Entity> for Entity {
  fn to() -> RelationDef {
    Relation::Account.def()
  }
}

impl Related<super::wallets::Entity> for Entity {
  fn to() -> RelationDef {
    Relation::Wallet.def()
  }
}

impl Related<super::categories::Entity> for Entity {
  fn to() -> RelationDef {
    Relation::Category.def()
  }
}

impl Related<super::integrations::Entity> for Entity {
  fn to() -> RelationDef {
    Relation::Integration.def()
  }
}

impl Related<super::bond_performances::Entity> for Entity {
  fn to() -> RelationDef {
    Relation::BondPerformance.def()
  }
}

impl Related<super::bond_monthly_performances::Entity> for Entity {
  fn to() -> RelationDef {
    Relation::BondMonthlyPerformance.def()
  }
}

impl Related<super::interest_rate_histories::Entity> for Entity {
  fn to() -> RelationDef {
    Relation::InterestRateHistories.def()
  }
}

impl ActiveModelBehavior for ActiveModel {}

impl Entity {
  pub async fn find_or_initialize_by_uid(uid : &str, integration_id: i64, db : &DatabaseConnection) -> Result<ActiveModel> {
    let resource = Self::find()
      .filter(Column::Uid.eq(uid))
      .filter(Column::IntegrationId.eq(integration_id))
      .one(db)
      .await?;

    if let Some(resource) = resource {
      return Ok(resource.into())
    }

    let mut resource = ActiveModel::new();
    resource.uid = Set(uid.to_owned());
    resource.integration_id = Set(Some(integration_id));

    Ok(resource)
  }

  /**
   * Find bonds that are expired, or not in passed bond ids and are not archived
   */
  pub fn update_candidates_as_archived(existing_bonds_ids: Vec<i64>, integration_id: i64) -> UpdateMany<Entity> {
    let mut attrs = ActiveModel::new();
    attrs.status = Set(BondStatus::Archived);

    let not_existing_bond_ids = Condition::all()
      .not()
      .add(Expr::col(Column::Id).is_in(existing_bonds_ids));
    let expired_or_not_in_bond_ids = Condition::any()
      .add(Expr::col(Column::EndDate).less_than(SimpleExpr::Custom("NOW()".to_owned())))
      .add(not_existing_bond_ids);

    let conditions = Condition::all()
      .add(Column::IntegrationId.eq(integration_id))
      .add(Column::Status.eq(BondStatus::Active))
      .add(expired_or_not_in_bond_ids);

    Self::update_many()
      .set(attrs)
      .filter(conditions)
  }
}

#[cfg(test)]
mod test {
  use sea_orm::{QueryTrait, DbBackend};
  use pretty_assertions::{assert_eq};
  use super::*;

  #[test]
  fn test_update_candidates_as_archived() {
    let bond_ids : Vec<i64> = vec![1,2,3];

    assert_eq!(
      Entity::update_candidates_as_archived(bond_ids, 12)
        .build(DbBackend::Postgres)
        .to_string(),
      r#"UPDATE "bonds" SET "status" = 'Archived' WHERE "bonds"."integration_id" = 12 AND "bonds"."status" = 'Active' AND ("end_date" < NOW() OR (NOT ("id" IN (1, 2, 3))))"#
    );
  }
}
