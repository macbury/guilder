//! SeaORM Entity. Generated by sea-orm-codegen 0.7.0

use sea_orm::entity::prelude::*;
use sea_orm::{EntityTrait, ConnectionTrait, Statement};
use serde::Serialize;
use anyhow::Result;

#[derive(Serialize, Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "bond_performances")]
#[serde(rename_all = "camelCase")]
pub struct Model {
  #[sea_orm(primary_key, auto_increment = false)]
  pub bond_id: i64,
  pub shares: Option<i64>,
  pub buyout_days_left: Option<i64>,
  pub interest_days_left: Option<i64>,
  pub start_price: Option<f64>,
  pub price: Option<f64>,
  pub buyout_price: Option<f64>,
  pub price_date: Date,
  pub current_rate: Option<f64>,
  pub last_price: Option<f64>,
  pub price_change: Option<f64>,
  pub percent_change: Option<f64>,
  pub day_price_change: Option<f64>,
  pub day_percent_change: Option<f64>,
  pub rates: Json
}

impl Entity {
  #[tracing::instrument(level="trace", skip(db))]
  pub async fn refresh(db: &DatabaseConnection) -> Result<()> {
    tracing::trace!("Refreshing materialized view");
    let refresh_query = Statement::from_string(
      db.get_database_backend(),
      "REFRESH MATERIALIZED VIEW bond_performances;".to_owned()
    );
    db.execute(refresh_query).await?;

    Ok(())
  }
}

#[derive(Copy, Clone, Debug, EnumIter)]
pub enum Relation {
  Bond
}

impl RelationTrait for Relation {
  fn def(&self) -> RelationDef {
    Entity::belongs_to(super::bonds::Entity)
      .from(Column::BondId)
      .to(super::bonds::Column::Id)
      .into()
  }
}

impl Related<super::bonds::Entity> for Entity {
  fn to() -> RelationDef {
    Relation::Bond.def()
  }
}

impl ActiveModelBehavior for ActiveModel {}

impl From<&Model> for Model {
  fn from(model: &Model) -> Self {
    let model = model.clone();
    model.into()
  }
}
