//! SeaORM Entity. Generated by sea-orm-codegen 0.7.0

use serde::Serialize;
use sea_orm::{entity::prelude::*, QueryOrder};
use trading_view::Ticker;

#[derive(Debug, Clone, PartialEq, EnumIter, DeriveActiveEnum, Serialize, Copy)]
#[sea_orm(rs_type = "String", db_type = "String(Some(2))")]
pub enum Kind {
  #[sea_orm(string_value = "P")]
  Price,
  #[sea_orm(string_value = "S")]
  StartPrice,
  #[sea_orm(string_value = "R")]
  Rate,
  #[sea_orm(string_value = "V")]
  Volume,
  #[sea_orm(string_value = "PD")]
  Period,
  #[sea_orm(string_value = "BP")]
  BuyoutPrice,
}

#[derive(Clone, Debug, PartialEq, DeriveEntityModel)]
#[sea_orm(table_name = "points")]
pub struct Model {
  #[sea_orm(primary_key)]
  pub id: i64,
  pub date: Date,
  pub kind: Kind,
  pub value: f64,
  pub resource_id: String,
  pub resource_type: String
}

#[derive(Copy, Clone, Debug, EnumIter, DeriveRelation)]
pub enum Relation {
  #[sea_orm(
    belongs_to = "super::assets::Entity",
    from = "Column::ResourceId",
    to = "super::assets::Column::Id",
    on_update = "NoAction",
    on_delete = "Cascade"
  )]
  Assets,
}

impl Related<super::assets::Entity> for Entity {
  fn to() -> RelationDef {
    Relation::Assets.def()
  }
}

impl ActiveModelBehavior for ActiveModel {

}

impl Model {
  pub fn ticker(&self) -> Ticker {
    self.resource_id.clone().into()
  }
}

impl Entity {
  pub fn newest(resource_type: String, resource_id: String, kind: Kind) -> Select<Entity> {
    Self::find()
      .filter(Column::ResourceType.eq(resource_type))
      .filter(Column::ResourceId.eq(resource_id))
      .filter(Column::Kind.eq(kind))
      .order_by_desc(Column::Date)
  }

  // fn distinct_newest_points_statement() -> SelectStatement {
  //   let statement = Query::select()
  //     .order_by_columns(vec![
  //       (Column::ResourceId, Order::Desc),
  //       (Column::Kind, Order::Desc),
  //       (Column::Date, Order::Desc),
  //     ])
  //     .order_by(Column::Date, Order::Desc)
  //     .expr(Expr::cust(
  //       r#"DISTINCT ON("points"."resource_id", "points"."kind") "points"."id""#,
  //     ))
  //     .from(Entity)
  //     .to_owned();
  //   statement
  // }

  // pub fn newest_points_for(tickers: &[Ticker], kinds: Option<Vec<Kind>>) -> SelectTwo<Entity, Asset> {
  //   let tickers : Vec<String> = tickers
  //       .iter()
  //       .map(|t| t.into())
  //       .collect();

  //   let statement = Self::distinct_newest_points_statement()
  //     .and_where(
  //       Expr::col(Column::ResourceId)
  //         .is_in(tickers)
  //     ).and_where(
  //       Expr::col(Column::ResourceType)
  //         .eq("Asset")
  //     )
  //     .and_where_option(kinds.map(|kinds|
  //       Expr::col(Column::Kind)
  //         .is_in(kinds)
  //     )).to_owned();

  //   Self::find()
  //     .filter(Column::Id.in_subquery(statement))
  //     .find_also_related(Asset)
  // }

  // pub fn newest_points(kinds: Option<Vec<Kind>>) -> SelectTwo<Entity, Asset> {
  //   let statement = Self::distinct_newest_points_statement()
  //     .and_where_option(kinds.map(|kinds|
  //       Expr::col(Column::Kind)
  //         .is_in(kinds)
  //     ))
  //     .to_owned();

  //   Self::find()
  //     .filter(Column::Id.in_subquery(statement))
  //     .find_also_related(Asset)
  // }

  // pub fn find_by_ticker_kind_and_at(ticker : &Ticker, kind: &Kind, at: Date) -> Select<Entity> {
  //   let ticker : String = ticker.into();
  //   Self::find()
  //     .filter(Column::ResourceId.eq(ticker))
  //     .filter(Column::ResourceType.eq("Asset"))
  //     .filter(Column::Kind.eq(kind.clone()))
  //     .filter(Column::Date.eq(at))
  // }

  // pub async fn upsert(db : &DatabaseConnection, ticker : &Ticker, kind: Kind, at: Date, value: f64) -> Result<bool> {
  //   let asset_id : String = ticker.into();
  //   let values : Vec<Value> = vec![
  //     asset_id.into(),
  //     "Asset".into(),
  //     kind.into(),
  //     at.into(),
  //     value.into()
  //   ];

  //   let statement = Statement::from_sql_and_values(DatabaseBackend::Postgres, r#"
  //     INSERT INTO points (resource_id, resource_type, kind, date, value)
  //     VALUES($1, $2, $3, $4)
  //     ON CONFLICT(resource_id, kind, date)
  //     DO
  //       UPDATE SET value = EXCLUDED.value;
  //   "#, values);

  //   db.execute(statement).await?;

  //   Ok(true)
  // }
}


// #[cfg(test)]
// mod test {
//   use sea_orm::{QueryTrait, DbBackend};
//   use pretty_assertions::{assert_eq};
//   use super::*;

//   #[test]
//   fn test_newest_points_for() {
//     let tickers : Vec<Ticker> = vec![
//       "USDPLN".into(),
//       "GPW:GPW".into(),
//     ];

//     assert_eq!(
//       Entity::newest_points_for(&tickers, None)
//         .build(DbBackend::Postgres)
//         .to_string(),
//       r#"SELECT "points"."id" AS "A_id", "points"."date" AS "A_date", "points"."kind" AS "A_kind", "points"."value" AS "A_value", "points"."asset_id" AS "A_asset_id", "assets"."id" AS "B_id", "assets"."name" AS "B_name", "assets"."description" AS "B_description", "assets"."website_url" AS "B_website_url", "assets"."isin" AS "B_isin", "assets"."currency" AS "B_currency", "assets"."logo_url" AS "B_logo_url", "assets"."country" AS "B_country", "assets"."currency_logo_url" AS "B_currency_logo_url", "assets"."exchange" AS "B_exchange", "assets"."category_id" AS "B_category_id" FROM "points" LEFT JOIN "assets" ON "points"."asset_id" = "assets"."id" WHERE "points"."id" IN (SELECT DISTINCT ON("points"."asset_id", "points"."kind") "points"."id" FROM "points" WHERE "asset_id" IN ('USDPLN', 'GPW:GPW') ORDER BY "asset_id" DESC, "kind" DESC, "date" DESC, "date" DESC)"#
//     );
//   }
// }
